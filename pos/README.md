# POS チェーンを作る

前回作った POW のチェーンを POS に改造します。加えて、P2P 通信のモジュールを追加して、前回は集権的にブロックを生成していたところを分散化させます。

## POW チェーンとの変更点

まず、前回のチェーンからの変更部分をリストアップします。前回の POW チェーンから変更した部分をピックアップします。

- コンセンサスを POW に変更
  - POW から POS に変更しました。これに伴って、Stake や Vote 等の POW にはない概念を実装しています。
- アカウントモデルに変更
  - UTXO からアカウントモデルに変更しました。アカウントモデルは Ethereum をはじめ世の POS なブロックチェーンが採用するモデルです。実は、当初は UTXO モデルを使い続ける予定でした。しかし、Stake と Vote を UTXO モデルで表現するのは不自然であったので、より自然な形で実装するためにアカウントモデルを採用しました。
- P2P レイヤの追加
  - 前回は単一の Node がブロックを積み上げる形だったので、他の Node との通信は不要でした。今回は、投票を実現したいので、複数 Node と通信するレイヤーを追加しました。

## POS でブロックを積み上げるステップ

POS はブロックを積み上げるまでに`投票して合意を得る`ことを行います。いくつかのステップを経るので解説します。
今回は投票数１回という最もシンプルな形に簡略化しました。Ethereum や Cosmos のようなパブリックブロックチェーンは複数回投票することで Security を高めています。

- Step1: ブロックのプロポーザを選出
  - 世の中の POS なブロックチェーンでは、ブロックのプロポーザを`Stake量に応じて`、`ブロック高さごとに決定的に選出`します。まず、Proof of Stake という名が示すとおり、Stake 量によってプロポーザに選出される確率が変わります。より Stake 量が多い Node がプロポーザに選ばれすくなります。ポイントは、とあるロジックに従って決定的に選ばれる点です。決定的である理由は、不正を検証するためです。当該ブロック高さのプロポーザを決定的に知れることにより、不正なプロポーザによって生成されたブロックを拒否できます。「とあるロジック」の部分はチェーンによって異なります。今回はブロック高さのハッシュ値を乱数として使っています。
- Step2: プロポーズされたブロックに投票
  - プロポーザに選出されなかった Node は、バリデータとしてブロックを検証する役割を担います。検証結果を投票という形で表明します。今回は、Yes/No の２択とし、検証結果が正であれば Yes に、不正であれば No に投票することにします。
- Step3: 投票の集計
  - プロポーザがバリデータから提出された投票結果を集計します。全体の合意を得られた場合は、正規のブロックをブロードキャストします(Step4 に進む)。今回は全体の 2/3 以上の賛同を得られた場合は、合意されたとみなします。
  - 得られなかった場合は、再度ブロックをプロポーズします（Step1 からやり直し）
- Step4: ブロックのブロードキャスト
  - 合意されたブロックをプロポーザがネットワーク全体に伝播させます。

## 通信プロトコルについて

Tinychain の Node は２つの通信プロトコルを使用しています。
一方は、同じみ、Wallet との通信用の JSON な HTTP です。前回と同じです。
もう一方は、P2P 通信用の Websocket です。P2P 通信について詳しく解説します。

![networking](./img/networking.png)

### P2P 通信

Blockchain の Node は双方向に通信する必要があります。なぜなら、ブロックのプロポーズや投票は相互に行う必要があるからです。したがって、HTTP のような単方向通信なプロトコルは使えません。また、Node 間の通信はブロックを早く積み上げるためにも、高速であることが求められます。なのでオーバーヘッドの少ないプロトコルが使用されます。チェーンの性能に直結するため GRPC 等のメジャーな規格ではなく、最適化した独自規格を使うチェーンも多いです。今回は、javascript で実装しやすいように Websocket を採用しました。

## アカウントモデルについて

アカウントモデルは、アカウントはとある状態（State）を持っていて、トランザクションによってその State を更新してゆきます。Bitcoin のデータモデルでる UTXO が、更新なしで追加だけのログや履歴のようなものであるのに対して、アカウントモデルは、通常のデータベースのようにデータを上書き更新します。

本実装の State は簡略化していて`balance`と`stake`だけを持ちます。そして`key`によって State はどのアカウントに紐づくのか判断します。key 値として、今回は公開鍵の値をそのまま使います。

```javascript
class State {
  constructor(addr, amount, stake = 0) {
    this.key = addr; // walletのpubkeyをkeyとして使う
    this.balance = amount;
    this.stake = stake; // stakeは簡略化のためGenesisStateからのみ設定する
  }
  ...
}
```

balance は Tinycoin の保有量を表します。プロポーザに与えられるブロック生成報酬や、バリデータのブロック検証報酬は、この balance を増やすことで実現されます。コインの送受信時も、この balance を更新します。
stake はステークされた Tinycoin の量を表します。１コインでも Stake されたらそのアカウントはバリデータであるとみなします。今回は簡略化のため、この stake を更新するしくみを実装していません。[GenesisState](./genesisStates.js)に設定された Stake 量から変動しないものとしています。

State は、Bitcoin や Ethereum 等のバブリックチェーンの場合、`AVL tree等の木構造`で`LevelDBのようなLoweLevelのKey-Valueストアに格納`されます。パフォーマンスを高めるのが目的です。
今回は、単純化のために配列の構造で、メモリ上に保持します。

```javascript
class StateStore {
  constructor(states = []) {
    this.states = states; // stateを配列の形で保持する
  }
  ...
}
```

## トランザクションのライフサイクル

前回と同様にトランザクションのライフサイクルを通して、コードを解説します。

- Step1: Transaction を作る
- Step3: Transaction Pool へ Transaction を追加する
- Step4: Block を Transaction Pool 内のトランザクションから作る
- Step5: マイニング
- Step6: Block をチェーンへ追加

### Step1: Transaction を作る
